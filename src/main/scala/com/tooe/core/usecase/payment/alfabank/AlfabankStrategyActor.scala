package com.tooe.core.usecase.payment.alfabank

import akka.actor.Props
import com.tooe.core.usecase.AppActor
import com.tooe.core.usecase.payment._
import com.tooe.core.application.Actors
import com.tooe.core.db.mysql.domain
import com.tooe.core.domain.CurrencyId
import com.tooe.core.util.Lang
import com.tooe.core.db.mysql.domain.Payment
import com.tooe.core.db.mysql.services.StateChangeResult
import com.tooe.core.usecase.payment.PaymentWorkflowActor.CheckResult
import scala.concurrent._
import com.tooe.core.usecase.payment.alfabank.GetOrderStatusExtendedResponse.PaymentSucceeded
import com.tooe.core.usecase.payment.alfabank.AlfabankHttpClientActor.PageView
import com.tooe.core.usecase.payment.InitPaymentRequest
import com.tooe.core.exceptions.ApplicationException
import com.typesafe.config.Config

object AlfabankStrategyActor {
  final val Id = Actors.AlfabankStrategy

  case class AlfabankInitPaymentResponse(url: String)

  /**
   * @param paymentUuid internal Payment.uuid
   * @param transactionId external, generated by the bank service
   */
  case class ReturnUrlCallback(paymentUuid: String, transactionId: String, lang: Lang, responseType: ResponseType)

  case class ReturnUrlCallbackResponse(url: String)
  object ReturnUrlCallbackResponse {
    def apply(url: String, paymentUuid: String, lang: Lang, responseType: ResponseType): ReturnUrlCallbackResponse =
      ReturnUrlCallbackResponse(UrlSubstituteHelper(url, paymentUuid, lang, responseType))
  }
}

class AlfabankStrategyActor extends AppActor {

  lazy val paymentWorkflowActor = lookup(Actors.PaymentWorkflow)
  lazy val paymentDataActor = lookup(Actors.PaymentData)

  val httpClient = context.actorOf(Props(new AlfabankHttpClientActor), "alfabank-http-client")

  val config = new PaymentAlfabankConfig(context.system.settings.config.getConfig("payment.alfabank"))

  class PaymentAlfabankConfig(config: Config) {
    import config._
    val ReturnUrl = getString("returnUrl")
    val SuccessUrl = getString("successUrl")
    val FailureUrl = getString("failureUrl")
    val timeoutBeforeCheckStatus = getMilliseconds("timeout-before-check-status")
  }

  import context.dispatcher
  import AlfabankStrategyActor._
  import config._

  def receive = {
    case InitPaymentRequest(request, routeContext, userId) =>
      (paymentWorkflowActor ? PaymentWorkflowActor.InitPayment(request, userId, routeContext)).mapTo[domain.Payment] flatMap { payment =>

        val preAuth = AlfabankHttpClientActor.RegisterPreAuth(
          amount = payment.amount,
          currency = CurrencyId(payment.currencyId),
          lang = routeContext.lang,
          orderNumber = payment.orderId,
          description = payment.productSnapshot.name,
          pageView = request.pageViewType.map(_ => PageView.Mobile).getOrElse(PageView.Desktop),
          returnUrl = UrlSubstituteHelper(ReturnUrl, payment.uuid, routeContext.lang, request.responseType)
        )

        (httpClient ? preAuth).mapTo[RegisterPreAuthResponse] flatMap {
          case RegisterPreAuthResponse.Successful(url) => Future successful AlfabankInitPaymentResponse(url)
          case resp =>
            val msg = s"Payment registration has failed request=$request response=$resp"
            log.error(msg)
            Future failed new ApplicationException(message = msg)
        }
      } pipeTo sender

    case ReturnUrlCallback(paymentUuid, transactionId, lang, responseType) =>
      import CheckResult._

      getPaymentOrderIdByUuid(paymentUuid) flatMap { orderId =>
        checkPayment(orderId) flatMap {
          case CheckPassed =>
            deposit(transactionId, lang) flatMap {
              case DepositResponse("0", msg) =>
                waitBeforeCheckStatus flatMap { _ =>
                  getOrderStatusExtended(transactionId, lang) flatMap {
                    case PaymentSucceeded(resp) =>
                      confirmPayment(orderId, transactionId) map { _ =>
                        ReturnUrlCallbackResponse(SuccessUrl, paymentUuid, lang, responseType)
                      }
                    case resp =>
                      log.error(s"Payment with uuid=$paymentUuid has failed during getOrderStatusExtended, response was: $resp")
                      Future successful ReturnUrlCallbackResponse(FailureUrl, paymentUuid, lang, responseType)
                  }
                }

              case resp =>
                log.error(s"Payment with uuid=$paymentUuid has failed during deposit, response was $resp")
                rejectPayment(orderId) map { _ =>
                  ReturnUrlCallbackResponse(FailureUrl, paymentUuid, lang, responseType)
                }
            }

          case CheckFailed =>
            //TODO in case CheckFailed should ask alfabank to reject payment, but as for now it never rejects payments on the checking phase
            Future successful ReturnUrlCallbackResponse(SuccessUrl, paymentUuid, lang, responseType)
        }
      } pipeTo sender
  }

  def waitBeforeCheckStatus = future {
    blocking {
      Thread.sleep(timeoutBeforeCheckStatus)
    }
  }

  def deposit(transactionId: String, lang: String): Future[DepositResponse] =
    (httpClient ? AlfabankHttpClientActor.Deposit(transactionId)).mapTo[DepositResponse]

  def getOrderStatusExtended(transactionId: String, lang: Lang): Future[GetOrderStatusExtendedResponse] =
    (httpClient ? AlfabankHttpClientActor.GetOrderStatusExtended(transactionId, lang)).mapTo[GetOrderStatusExtendedResponse]

  def getPaymentOrderIdByUuid(orderUuid: String): Future[Payment.OrderId] =
    (paymentDataActor ? PaymentDataActor.GetPaymentByUuid(orderUuid)).mapTo[Payment] map (_.orderId)

  def checkPayment(orderId: Payment.OrderId): Future[CheckResult] =
    (paymentWorkflowActor ? PaymentWorkflowActor.CheckPayment(orderId)).mapTo[CheckResult]

  def rejectPayment(orderId: Payment.OrderId): Future[StateChangeResult] =
    (paymentWorkflowActor ? PaymentWorkflowActor.RejectPayment(orderId)).mapTo[StateChangeResult]

  def confirmPayment(orderId: Payment.OrderId, transactionId: String): Future[StateChangeResult] =
    (paymentWorkflowActor ? PaymentWorkflowActor.ConfirmPayment(orderId, transactionId, fullPrice = None)).mapTo[StateChangeResult]
}